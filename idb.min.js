/*!
 * idb.js IndexedDB wrapper v2.0
 * Licensed under the MIT license
 * Copyright (c) 2018 Lukas Jans
 * https://github.com/Luniversity/idb
 */
class IDB{static connect(e){this.connection=new Promise((t,r)=>{const n=indexedDB.open(e.name,e.version||1);n.onerror=(()=>r(n.error)),n.onsuccess=(()=>t(n.result)),n.onupgradeneeded=(()=>{const t=n.result;for(const e of t.objectStoreNames)t.deleteObjectStore(e);for(const r of e.tables)t.createObjectStore(r.name,r.options)})});for(const t of e.tables)this[t.name]=new IDB.Table(t.name)}}IDB.Table=class{constructor(e){this.name=e}transaction(){return new Promise((e,t)=>{IDB.connection.then(t=>{e(t.transaction([this.name],"readwrite").objectStore(this.name))})})}promise(e){return new Promise((t,r)=>{e.onerror=(()=>r(e.error)),e.onsuccess=(()=>t(e.result))})}set(e,t){return this.transaction().then(r=>this.promise(r.put(t,e)))}get(e){return this.transaction().then(t=>this.promise(t.get(e)))}all(){return this.transaction().then(e=>new Promise((t,r)=>{var n={},s=e.openCursor();s.onerror=(()=>r(s.error)),s.onsuccess=(()=>{var e=s.result;e?(n[e.key]=e.value,e.continue()):t(n)})}))}where(e){return this.all().then(t=>{var r={};for(var n in t)e(t[n])&&(r[n]=t[n]);return r})}clear(){return this.transaction().then(e=>this.promise(e.clear()))}delete(e){return this.transaction().then(t=>this.promise(t.delete(e)))}add(e){return this.transaction().then(t=>this.promise(t.put(e)))}};