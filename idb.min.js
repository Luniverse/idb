/*!
 * idb.js IndexedDB wrapper v2.3
 * Licensed under the MIT license
 * Copyright (c) 2018 Lukas Jans
 * https://github.com/luniverse/idb
 */
class IDB{static connect(e,r={}){this.connection=new Promise((t,n)=>{const o=indexedDB.open(r.name||"IDB",r.version||1);o.onerror=(()=>n(o.error)),o.onsuccess=(()=>t(o.result)),o.onupgradeneeded=(()=>{const r=o.result;for(const e of r.objectStoreNames)r.deleteObjectStore(e);for(const t of e)r.createObjectStore(t.name,t.options)})});for(const r of e)this[r.name]=new IDB.Table(r.name)}}IDB.Table=class{constructor(e){this.name=e}transaction(e){return IDB.connection.then(r=>{const t=r.transaction(this.name,"readwrite").objectStore(this.name),n=e(t);return n instanceof Promise?n:new Promise((e,r)=>{n.onerror=(()=>r(n.error)),n.onsuccess=(()=>e(n.result))})})}set(e,r){return this.transaction(t=>t.put(r,e))}get(e){return this.transaction(r=>r.get(e))}all(){return this.transaction(e=>new Promise((r,t)=>{var n={},o=e.openCursor();o.onerror=(()=>t(o.error)),o.onsuccess=(()=>{var e=o.result;e?(n[e.key]=e.value,e.continue()):r(n)})}))}where(e){return this.all().then(r=>{var t={};for(var n in r)e(r[n])&&(t[n]=r[n]);return t})}clear(){return this.transaction(e=>e.clear())}delete(e){return this.transaction(r=>r.delete(e))}add(e){return this.transaction(r=>r.put(e))}};