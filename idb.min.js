/*!
 * idb.js IndexedDB wrapper v2.1
 * Licensed under the MIT license
 * Copyright (c) 2018 Lukas Jans
 * https://github.com/luniverse/idb
 */
class IDB{static connect(e){this.connection=new Promise((t,r)=>{const n=indexedDB.open(e.name,e.version||1);n.onerror=(()=>r(n.error)),n.onsuccess=(()=>t(n.result)),n.onupgradeneeded=(()=>{const t=n.result;for(const e of t.objectStoreNames)t.deleteObjectStore(e);for(const r of e.tables)t.createObjectStore(r.name,r.options)})});for(const t of e.tables)this[t.name]=new IDB.Table(t.name)}}IDB.Table=class{constructor(e){this.name=e}transaction(e){return IDB.connection.then(t=>{const r=t.transaction(this.name,"readwrite").objectStore(this.name),n=e(r);return n instanceof Promise?n:new Promise((e,t)=>{n.onerror=(()=>t(n.error)),n.onsuccess=(()=>e(n.result))})})}set(e,t){return this.transaction(r=>r.put(t,e))}get(e){return this.transaction(t=>t.get(e))}all(){return this.transaction(e=>new Promise((t,r)=>{var n={},o=e.openCursor();o.onerror=(()=>r(o.error)),o.onsuccess=(()=>{var e=o.result;e?(n[e.key]=e.value,e.continue()):t(n)})}))}where(e){return this.all().then(t=>{var r={};for(var n in t)e(t[n])&&(r[n]=t[n]);return r})}clear(){return this.transaction(e=>e.clear())}delete(e){return this.transaction(t=>t.delete(e))}add(e){return this.transaction(t=>t.put(e))}};